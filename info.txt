
Philo intro:

One or more philosophers sit at a round table.
There is a large bowl of spaghetti in the middle of the table.

•The philosophers alternatively eat, think, or sleep.
While they are eating, they are not thinking nor sleeping;
while thinking, they are not eating nor sleeping;
and, of course, while sleeping, they are not eating nor thinking.

•There are also forks on the table. There are as many forks as philosophers.

•Because serving and eating spaghetti with only one fork is very inconvenient,
a philosopher takes their right and their left forks to eat, one in each hand.

•When a philosopher has finished eating, they put their forks back on the table and
start sleeping. Once awake, they start thinking again. The simulation stops when
a philosopher dies of starvation.

•Every philosopher needs to eat and should never starve.

•Philosophers don’t speak with each other.

•Philosophers don’t know if another philosopher is about to die.

•No need to say that philosophers should avoid dying!

//

Things to learn and use:

- Threading
Learn how to create and manage threads.

- Mutexes
Mutual exclusion ensures that 
only one thread accesses a shared resource at a time.

- Semaphores
Counting semaphores can be used 
to control access to a shared resource.

- Deadlocks & Starvation
Understand these issues in concurrency.

- Process Synchronization
Techniques to make sure multiple threads or processes 
operate without unexpected outcomes or conflicts.


Steps to implement:

1. Setup
	- Define the number of philo (as program arguments)
	- Initialize forks (either as mutexes or semaphores)
	- Initialize philo's states (thinking, eating, sleeping)

2. Thread creation
	- For each philo, create a separate thread
	- Each philo will follow the cycle:
		think->get forks->eat->put forks down->sleep

3. Handling forks
	- A philo should be able to pickup the two forks adjacent to him,
		but should wait if one of them is unavailable
	- Implement the logic to prevent simultaneous acces to a forks
		(use mutexes/semaphores)

4. Avoid deadlocks
	- Ensure that all philos don't try to pickup the left fork at once
		(this could lead to a scenario where each philo is holding one fork,
			waiting indefinetly for the other)
	- One common solution: Let one philo pickup the right fork first,
		instead of the left, or use a waiter or arbitrator concept to control
			access to forks.

5. Monitoring philosopher states
	- The state of the pilosopher (whether eating, thinking or sleeping)
		should be visible (print the state to the console)
	- Use mutexes to ensure synchronized acces to the printing function,
		to avoid jumbled outputs

6. Avoid starvation
	- Ensure that no philosopher is left starving,
		i.e., a philo should not be deprived of eating for an indefinite time
	- One way is to introduce fairness in fork aquisition or use a timer
		to ensure everyone gets a turn

7. Cleanup
	- Once the simulation ends, ensure that all threads are safely terminated
		and ressources are freed

8. Bonus
	- Introduce more realistic scenarios.
		Maybe philosophers have a certain lifespan, or varying hunger levels
	- Implement priority mechanisms 
		to simulate different philosophies about ressource sharing

This project is about understanding concurrency issues and resolving them.
Will need to get the basics of multithreading and synchronization right,
	and from there it is about problem-solving.

//

